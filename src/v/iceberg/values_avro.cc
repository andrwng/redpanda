// Copyright 2024 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0
#include "iceberg/values_avro.h"

#include "base/units.h"
#include "base/vlog.h"
#include "bytes/bytes.h"
#include "bytes/iobuf_parser.h"
#include "iceberg/avro_utils.h"
#include "iceberg/logger.h"
#include "iceberg/schema_avro.h"
#include "iceberg/values.h"

#include <avro/Generic.hh>
#include <avro/GenericDatum.hh>
#include <avro/Schema.hh>

namespace iceberg {

namespace {

// Returns the Avro datum corresponding to the given value. The value is
// expected to match the given Avro schema.
//
// The given value may be null if the schema refers to an optional value.
avro::GenericDatum
val_to_avro_datum(const std::optional<value>&, const avro::NodePtr&);
avro::GenericDatum val_to_avro_datum(const value&, const avro::NodePtr&);

// Returns the Avro datum corresponding to the given struct value. The value is
// expected to match the given Avro RECORD schema.
avro::GenericDatum
struct_to_avro_datum(const struct_value&, const avro::NodePtr&);

// XXX: need to figure out how to correctly instantiate avro::GenericFixed to
// support the unimplemented fields. Throw for now.
struct primitive_value_avro_visitor {
    template<typename ValueT>
    avro::GenericDatum operator()(const ValueT& v) {
        return {v.val};
    }
    avro::GenericDatum operator()(const string_value& v) {
        const auto size_bytes = v.val.size_bytes();
        iobuf_const_parser buf(v.val);
        return {buf.read_string(size_bytes)};
    }
    avro::GenericDatum operator()(const binary_value& v) {
        std::vector<uint8_t> data;
        auto bytes = iobuf_to_bytes(v.val);
        data.resize(bytes.size());
        for (size_t i = 0; i < bytes.size(); i++) {
            data[i] = bytes[i];
        }
        return {data};
    }
    avro::GenericDatum operator()(const decimal_value&) {
        throw std::invalid_argument("XXX decimal not implemented");
    }
    avro::GenericDatum operator()(const fixed_value&) {
        throw std::invalid_argument("XXX fixed not implemented");
    }
    avro::GenericDatum operator()(const date_value& v) { return {v.val}; }
    avro::GenericDatum operator()(const time_value& v) { return {v.val}; }
    avro::GenericDatum operator()(const timestamp_value& v) { return {v.val}; }
    avro::GenericDatum operator()(const timestamptz_value& v) {
        return {v.val};
    }
    avro::GenericDatum operator()(const uuid_value&) {
        throw std::invalid_argument("XXX uuid not implemented");
    }
};

struct value_avro_visitor {
    explicit value_avro_visitor(const avro::NodePtr& avro_schema)
      : avro_schema_(avro_schema) {}

    // Expected to match with the value on which the caller is calling
    // operator().
    const avro::NodePtr& avro_schema_;

    avro::GenericDatum operator()(const primitive_value& v) {
        return std::visit(primitive_value_avro_visitor{}, v);
    }
    avro::GenericDatum operator()(const std::unique_ptr<struct_value>& v) {
        return struct_to_avro_datum(*v, avro_schema_);
    }
    avro::GenericDatum operator()(const std::unique_ptr<list_value>& v) {
        avro::GenericDatum datum(avro_schema_);
        auto& arr = datum.value<avro::GenericArray>();
        const auto& child_schema = avro_schema_->leafAt(0);
        for (const auto& element_ptr : v->elements) {
            arr.value().emplace_back(
              val_to_avro_datum(element_ptr, child_schema));
        }
        return datum;
    }
    avro::GenericDatum operator()(const std::unique_ptr<map_value>& v) {
        avro::GenericDatum datum(avro_schema_);
        auto& m = datum.value<avro::GenericArray>();
        const auto& kv_schema = avro_schema_->leafAt(0);
        // Map Avro schemas are generated by Redpanda as an array of key-value
        // records.
        vassert(
          kv_schema->leaves() == 2,
          "Expected 2 leaves: {}",
          kv_schema->leaves());
        for (const auto& kv_ptr : v->kvs) {
            avro::GenericDatum kv_datum(kv_schema);
            auto& kv_record = kv_datum.value<avro::GenericRecord>();
            kv_record.setFieldAt(
              0, val_to_avro_datum(kv_ptr.key, kv_schema->leafAt(0)));
            kv_record.setFieldAt(
              1, val_to_avro_datum(kv_ptr.val, kv_schema->leafAt(1)));
            m.value().emplace_back(std::move(kv_datum));
        }
        return datum;
    }
};

avro::GenericDatum
struct_to_avro_datum(const struct_value& v, const avro::NodePtr& avro_schema) {
    if (avro_schema->type() != avro::AVRO_RECORD) {
        throw std::invalid_argument(fmt::format(
          "Avro schema has type {}", avro::toString(avro_schema->type())));
    }
    avro::GenericDatum datum(avro_schema);
    auto& record = datum.value<avro::GenericRecord>();
    if (record.fieldCount() != v.fields.size()) {
        throw std::invalid_argument(fmt::format(
          "Struct value does not match given Avro schema: {} "
          "fields vs expected {}: {}",
          v.fields.size(),
          record.fieldCount(),
          v));
    }
    for (size_t i = 0; i < v.fields.size(); i++) {
        const auto& child_val_ptr = v.fields[i];
        const auto& child_schema = avro_schema->leafAt(i);
        record.setFieldAt(i, val_to_avro_datum(child_val_ptr, child_schema));
    }
    return datum;
}

avro::GenericDatum
val_to_avro_datum(const value& val, const avro::NodePtr& avro_schema) {
    return std::visit(value_avro_visitor{avro_schema}, val);
}
avro::GenericDatum val_to_avro_datum(
  const std::optional<value>& val, const avro::NodePtr& avro_schema) {
    // NOTE: there isn't enough typing metadata to infer from the value alone
    // if this is optional or not, so we must rely on the schema.
    //
    // In Iceberg, this is represented as a union, and is the only valid use of
    // union in Iceberg data files.
    if (avro_schema->type() == avro::AVRO_UNION) {
        // Union Avro schemas are generated by Redpanda for optional fields,
        // which should have just two leaves.
        vassert(
          avro_schema->leaves() == 2,
          "Expected 2 leaves: {}",
          avro_schema->leaves());
        if (val == std::nullopt) {
            avro::GenericDatum ret(avro_schema);
            ret.selectBranch(0);
            return ret;
        }
        avro::GenericDatum ret(
          avro_schema, val_to_avro_datum(val, avro_schema->leafAt(1)));
        ret.selectBranch(1);
        return ret;
    }
    if (val == std::nullopt) {
        throw std::invalid_argument(fmt::format(
          "Value is null but expected {} type",
          avro::toString(avro_schema->type())));
    }
    return val_to_avro_datum(*val, avro_schema);
}

} // namespace

iobuf struct_to_avro_buf(
  const struct_value& v,
  const struct_type& t,
  const ss::sstring& struct_name,
  std::map<std::string, std::string> metadata) {
    const auto avro_schema = avro::ValidSchema(
      struct_type_to_avro(t, struct_name));
    auto v_datum = struct_to_avro_datum(v, avro_schema.root());
    size_t bytes_streamed{0};
    avro_iobuf_ostream::buf_container_t bufs;
    auto out = std::make_unique<avro_iobuf_ostream>(
      4_KiB, &bufs, &bytes_streamed);
    {
        avro::DataFileWriter<avro::GenericDatum> writer(
          std::move(out), avro_schema, 16_KiB, avro::NULL_CODEC, metadata);
        writer.write(v_datum);
        writer.flush();

        // NOTE: ~DataFileWriter does a final sync which may write to the
        // chunks. Destruct the writer before moving ownership of the chunks.
    }
    iobuf buf;
    for (auto& b : bufs) {
        buf.append(std::move(b));
    }
    if (buf.size_bytes() > bytes_streamed) {
        buf.trim_back(buf.size_bytes() - bytes_streamed);
    }
    return buf;
}

} // namespace iceberg
