// Copyright 2024 Redpanda Data, Inc.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.md
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0
#include "iceberg/values_avro.h"

#include "bytes/iobuf_parser.h"
#include "iceberg/values.h"

#include <avro/Generic.hh>
#include <avro/GenericDatum.hh>
#include <avro/Node.hh>

namespace iceberg {

namespace {

// Returns the Avro datum corresponding to the given value. The value is
// expected to match the given Avro schema.
//
// The given value may be null if the schema refers to an optional value.
avro::GenericDatum
val_to_avro(const std::optional<value>&, const avro::NodePtr&);
avro::GenericDatum base_val_to_avro(const value&, const avro::NodePtr&);

// XXX: need to figure out how to correctly instantiate avro::GenericFixed to
// support the unimplemented fields. Or move to an impl that uses iobufs. Throw
// for now.
struct primitive_value_avro_visitor {
    template<typename ValueT>
    avro::GenericDatum operator()(const ValueT& v) {
        return {v.val};
    }
    avro::GenericDatum operator()(const string_value& v) {
        const auto size_bytes = v.val.size_bytes();
        iobuf_const_parser buf(v.val);
        return {buf.read_string(size_bytes)};
    }
    avro::GenericDatum operator()(const binary_value& v) {
        std::vector<uint8_t> data;
        auto bytes = iobuf_to_bytes(v.val);
        data.resize(bytes.size());
        for (size_t i = 0; i < bytes.size(); i++) {
            data[i] = bytes[i];
        }
        return {data};
    }
    avro::GenericDatum operator()(const decimal_value&) {
        throw std::invalid_argument("XXX decimal not implemented");
    }
    avro::GenericDatum operator()(const fixed_value&) {
        throw std::invalid_argument("XXX fixed not implemented");
    }
    avro::GenericDatum operator()(const uuid_value&) {
        throw std::invalid_argument("XXX uuid not implemented");
    }
};

struct value_avro_visitor {
    explicit value_avro_visitor(const avro::NodePtr& avro_schema)
      : avro_schema_(avro_schema) {}

    // Expected to match with the value on which the caller is calling
    // operator().
    const avro::NodePtr& avro_schema_;

    avro::GenericDatum operator()(const primitive_value& v) {
        return std::visit(primitive_value_avro_visitor{}, v);
    }
    avro::GenericDatum operator()(const std::unique_ptr<struct_value>& v) {
        return struct_to_avro(*v, avro_schema_);
    }
    avro::GenericDatum operator()(const std::unique_ptr<list_value>& v) {
        if (avro_schema_->leaves() != 1) {
            throw std::invalid_argument(
              fmt::format("Expected 1 leaf: {}", avro_schema_->leaves()));
        }
        avro::GenericDatum datum(avro_schema_);
        auto& arr = datum.value<avro::GenericArray>();
        const auto& child_schema = avro_schema_->leafAt(0);
        for (const auto& element_ptr : v->elements) {
            arr.value().emplace_back(val_to_avro(element_ptr, child_schema));
        }
        return datum;
    }
    avro::GenericDatum operator()(const std::unique_ptr<map_value>& v) {
        avro::GenericDatum datum(avro_schema_);
        auto& m = datum.value<avro::GenericArray>();
        const auto& kv_schema = avro_schema_->leafAt(0);
        // Map Avro schemas are generated by Redpanda as an array of key-value
        // records.
        if (kv_schema->leaves() != 2) {
            throw std::invalid_argument(
              fmt::format("Expected 2 leaves: {}", kv_schema->leaves()));
        }
        for (const auto& kv_ptr : v->kvs) {
            avro::GenericDatum kv_datum(kv_schema);
            auto& kv_record = kv_datum.value<avro::GenericRecord>();
            kv_record.setFieldAt(
              0, base_val_to_avro(kv_ptr.key, kv_schema->leafAt(0)));
            kv_record.setFieldAt(
              1, val_to_avro(kv_ptr.val, kv_schema->leafAt(1)));
            m.value().emplace_back(std::move(kv_datum));
        }
        return datum;
    }
};

avro::GenericDatum
base_val_to_avro(const value& val, const avro::NodePtr& avro_schema) {
    return std::visit(value_avro_visitor{avro_schema}, val);
}
avro::GenericDatum
val_to_avro(const std::optional<value>& val, const avro::NodePtr& avro_schema) {
    if (!avro_schema) {
        throw std::invalid_argument("Null schema for val!");
    }
    // NOTE: there isn't enough typing metadata to infer from the value alone
    // if this is optional or not, so we must rely on the schema.
    //
    // In Iceberg, this is represented as a union, and is the only valid use of
    // union in Iceberg data files.
    if (avro_schema->type() == avro::AVRO_UNION) {
        // Union Avro schemas are generated by Redpanda for optional fields,
        // which should have just two leaves.
        if (avro_schema->leaves() != 2) {
            throw std::invalid_argument(
              fmt::format("Expected 2 leaves: {}", avro_schema->leaves()));
        }
        auto un = avro::GenericUnion(avro_schema);
        if (val == std::nullopt) {
            un.selectBranch(0);
            return avro::GenericDatum(avro_schema, un);
        }
        un.selectBranch(1);
        un.datum() = val_to_avro(val, avro_schema->leafAt(1));
        return avro::GenericDatum(avro_schema, un);
    }
    if (!val.has_value()) {
        throw std::invalid_argument(fmt::format(
          "Value is null but expected {} type",
          avro::toString(avro_schema->type())));
    }
    return base_val_to_avro(*val, avro_schema);
}

} // namespace

avro::GenericDatum
struct_to_avro(const struct_value& v, const avro::NodePtr& avro_schema) {
    if (!avro_schema) {
        throw std::invalid_argument("Null schema for struct val!");
    }
    if (avro_schema->type() != avro::AVRO_RECORD) {
        throw std::invalid_argument(fmt::format(
          "Avro schema has type {}", avro::toString(avro_schema->type())));
    }
    avro::GenericDatum datum(avro_schema);
    auto& record = datum.value<avro::GenericRecord>();
    if (record.fieldCount() != v.fields.size()) {
        throw std::invalid_argument(fmt::format(
          "Struct value does not match given Avro schema: {} "
          "fields vs expected {}: {}",
          v.fields.size(),
          record.fieldCount(),
          v));
    }
    for (size_t i = 0; i < v.fields.size(); i++) {
        const auto& child_val_ptr = v.fields[i];
        const auto& child_schema = avro_schema->leafAt(i);
        record.setFieldAt(i, val_to_avro(child_val_ptr, child_schema));
    }
    return datum;
}

} // namespace iceberg
